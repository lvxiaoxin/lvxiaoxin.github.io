---
layout: post
title: DFS之我的理解
categories: 刷题 
description: 递归
keywords: LeetCode Job 刷题
---


>  注：本题是基础的dfs题目，也是略有技巧性的dfs题目，所以详细解读一下我对dfs的理解


## 棋盘问题
Time Limit: 1000ms
Memory Limit: 10000KB

问题描述：
在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。

Input
输入含有多组测试数据。 
每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n <= 8 , k <= n 
当为-1 -1时表示输入结束。 
随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。

Output
对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C<2^31）。

Sample Input

```
2 1
#.
.#
4 4
...#
..#.
.#..
#...
-1 -1
```

Sample Output

```
2
1
```



## 问题分析

看到这个题目，第一反应就是dfs遍历求解，事实证明这是正确的。
那么接下来，问题就变成了解决以下几个难点：

1. 如何保证不重行，不重列。
2. 当k < n的时候，如何从这n行数据棋盘数据中，首先挑出有棋盘区域的行，再挑出选用其中的那几行。

首先，当k=n的时候，那么必然每一行都会用到一个数据，也就是说除非棋盘每一行都有棋盘区域，否则不可能有摆放位置。当k < n时候，需要从n行棋盘中，首先挑出有棋盘区域的m行，再从m行中选出k行来放棋子。这里会涉及一个组合的生成C(m, k)。当解决了组合数的问题后，就是保证不重行不重列的问题。初步设想是给棋盘位置设置一个vis数组，用来标记，然后通过：

```
bool conflict(int x, int y)
{
    for(int i=0; i<n; i++)
    {
        if(vis[x][i]==1)
            return true;
    }
    for(int i=0; i<n; i++)
    {
        if(vis[i][y]==1)
            return true;
    }
    return false;
}
```
来返回是否冲突。
看起来似乎一切顺利……

——————————————————————————分割线

然而！
最重要的问题，从哪儿开始dfs？？？！

问题源于上面的组合，当k < n 的时候，有些行是不使用的，那dfs可能就要通过循环控制起点，但是，这势必会造成极差的时间复杂度，而且一定会进行大量的重复子问题计算。

所以，上述方法不成立。

换思路。

——————————————————————————分割线



既然判断从哪儿dfs开始很困难，换句话说，也就是选择dfs(x, y)的参数a和b很困难。这说明，这道题dfs的参数根本就不应该是坐标！！！

那是什么？
我们在这里采用分治的思想，把问题一步一步拆分成子问题。
要解决k个棋子的问题，也就是要解决k-1个棋子的子问题再乘以第k个棋子的方法数；要解决k-1个棋子的问题，也就是要解决k-2个棋子的子问题…………如此递归下去，直至要解决0个棋子的问题的时候，就是到终点要return的时候了。

那么，我们换一种方法控制不充行，不重列。

首先，dfs的经典三层结构是亘古不变的真理：

```
dfs()
{
	if条件判断——（到终点） 
	{
		操作……
		return;
	}
	if……省略一些条件判断（剪枝优化，比如一些没必要的continue或者计算过的子问题的标记备忘录直接存取）
	for()
		if……满足条件的筛选
		修改标记；
		dfs();
		改回标记；
}
```

> 注：有些情况下是不需要dfs三层结构第三层：改回标记 这一操作的，见bnuoj12921或bnuoj1681, 这种情况多是因为：需要遍历全部满足题意的点，是纯粹的深度优先搜索遍历全部可走点



从这个角度出发，我们思考一下：

首先，return的条件是什么？肯定是到终点了，所以肯定需要进行一些操作，比如某个count++，然后return
if条件判断，剪枝优化，毕竟dfs……毕竟递归……能优化尽量优化……

接下来是dfs递归的核心部分：

我们不妨从第0行开始，这时候需要处理的是k个棋子，对第0行遍历，找到一个满足题意的‘#’区域后，我们知道以后这一列都不能用了，我们vis数组可以只建立为一维数组，只存储用过的行就可以，然后深层搜索，即dfs，这时候，我们就要从第1行开始搜索了（正因为这样，vis才不用存储行是否用过的冲突问题），此时需要处理的是k-1个棋子，我们同样是对第1行所有元素都遍历，找‘#’，只不过对于之前vis标记过得那一列，我们也不选用，找到后，再次标记，然后dfs……………………dfs进入第i行，对第i行遍历，当前需要处理的是k-i个棋子的问题，筛掉非棋盘区域和之前标记过得列，找到'#'，标记，然后dfs()………………知道某一次dfs进入后，发现当前处理棋子数量为0，说明到头了，这是找到了一种方法 ，count++，return，假设这是第一次return，那么将返回到第k-1行，继续寻找满足的‘#’，重复…………知道某一次return会到第0行了，那么，将从第1行继续作为dfs的第一次起始，这就相当于改变控制了dfs起始的位置。

下面附上代码：

![](https://res.cloudinary.com/lvxiaoxin96/image/upload/v1550853786/carbon_6.png)

这道题目告诉了我们一个道理………………对于dfs来说，每次dfs传递的参数，往往是显示和决定思路的关键。